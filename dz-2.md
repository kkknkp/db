Открыть в докере 2 сеанса, запустить везде psql из-под пользователя postgres.
docker run --name some-postgres -e POSTGRES_PASSWORD=postgres -d postgres
Терминал 1: docker exec -it some-postgres psql -U postgres
Терминал 2: docker exec -it some-postgres psql -U postgres

Создание таблицы в первой сессии:
CREATE TABLE test_table (id SERIAL PRIMARY KEY, data TEXT);
INSERT INTO test_table (data) VALUES ('row1'), ('row2');

Посмотреть текущий уровень изоляции:
SHOW TRANSACTION ISOLATION LEVEL;

Начать новую транзакцию:
BEGIN;

Добавить новую запись в первой сессии:
INSERT INTO test_table (data) VALUES ('row3');

Запрос на выбор во второй сессии:
SELECT * FROM test_table;

Нет, новую запись не видно, потому что уровень изоляции по умолчанию — READ COMMITTED, а транзакция в первой сессии еще не завершена.

Завершить транзакцию в первой сессии:
COMMIT;

Выполнить запрос на выбор во второй сессии
SELECT * FROM test_table;

Да, потому что первая транзакция была зафиксирована и теперь она доступна.

Завершить транзакцию во второй сессии
COMMIT;

Начать новые транзакции с уровнем repeatable read в обеих сессиях
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;

Добавить новую запись в первой сессии
INSERT INTO test_table (data) VALUES ('row4');

Выполнить запрос на выбор во второй сессии
SELECT * FROM test_table;

 Нет, потому что выполнение второй сессии под уровнем изоляции фиксирует вид данных на момент начала транзакции.

Завершите транзакцию в первой сессии
COMMIT;

Выполнить запрос на выбор во второй сессии
SELECT * FROM test_table;

Нет, вторая сессия зафиксировала своё состояние данных на момент начала транзакции, а изменения, произошедшие после этого, ей недоступны. 





9. Нет, новую запись не видно, потому что уровень изоляции по умолчанию — READ COMMITTED, а транзакция в первой сессии еще не завершена.
10. Да, потому что первая транзакция была зафиксирована и теперь она доступна.
17. Нет, потому что выполнение второй сессии под уровнем изоляции фиксирует вид данных на момент начала транзакции.
20. Нет, вторая сессия зафиксировала своё состояние данных на момент начала транзакции, а изменения, произошедшие после этого, ей недоступны. 
